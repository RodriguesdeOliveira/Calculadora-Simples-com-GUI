
import customtkinter as ctk
from tkinter import StringVar
import tkinter.constants as constants

ctk.set_appearance_mode('dark')

''' Função de calculo base'''
def calcular(n1, n2, op):
    if op == '+': return n1 + n2
    elif op == '-': return n1 - n2
    elif op == '*': return n1 * n2
    elif op == '/': 
        if n2 != 0: return n1 / n2 #Tratativa para divisão por 0
        else: return None
    return None

''' Classe principal da calculadora (visual)'''
class Calcular:
    def __init__(self, calc): #Construtor da Classe
        self.calc = calc
        calc.title('Calculadora')
        calc.geometry('250x400')
        calc.resizable(False, False)

        '''Estados da Calculadora'''
        self.display = StringVar(value= '0')
        self.num_atual = '0'
        self.n1 = None
        self.op = None
        self.new_num = False

        '''Display da Calculadora'''
        # Corrigido: 'textvar' para 'textvariable'
        self.display_widget = ctk.CTkLabel(calc, textvariable=self.display, font=('Arial', 30, 'bold'),
                                           anchor='e', corner_radius=15, height=70,
                                           fg_color=('#333333', '#222222'), text_color='white')
        self.display_widget.grid(row=0, column=0, columnspan=4, padx=5, pady=5, sticky=constants.W + constants.E)
        
        '''Criação de botões e vinculação ao clique do teclado'''
        self.buttons()
        calc.bind('<Key>', self.handle_key_press)

    '''Visual e posicionamento dos botões'''
    def buttons(self): # texto, linha, coluna, espaço e cor
        buttons = [
            ('C', 1, 0, 1, "#CC3300"), ('/', 1, 3, 1, "#FF9900"),
            ('7', 2, 0, 1, "#555555"), ('8', 2, 1, 1, "#555555"), ('9', 2, 2, 1, "#555555"), ('*', 2, 3, 1, "#FF9900"),
            ('4', 3, 0, 1, "#555555"), ('5', 3, 1, 1, "#555555"), ('6', 3, 2, 1, "#555555"), ('-', 3, 3, 1, "#FF9900"),
            ('1', 4, 0, 1, "#555555"), ('2', 4, 1, 1, "#555555"), ('3', 4, 2, 1, "#555555"), ('+', 4, 3, 1, "#FF9900"),
            ('0', 5, 0, 2, "#555555"), ('.', 5, 2, 1, "#555555"), ('=', 5, 3, 1, "#0198A5")        
        ]
        # Colunas iguais (0 = visor)
        for i in range(4): self.calc.grid_columnconfigure(i, weight=1, uniform='button_col')
        # Linhas iguais (0 = visor)
        for i in range(1,6): self.calc.grid_rowconfigure(i, weight=1, uniform='button_row')
        # Informações dos botões / comando
        for (text, row, col, columnspan, color) in buttons:
            command = None
            if text == 'C': command = self.clear_all
            elif text == '=': command = self.calcular
            elif text in ['+', '-', '*', '/']: command = lambda op=text: self.select_op(op)
            elif text == '.': command = self.append_decimal
            else: command = lambda num=text: self.append_num(num)

            button = ctk.CTkButton(self.calc, text=text, command=command, font=('Arial', 20, 'bold'),
                                   corner_radius=15, fg_color=color, hover_color=self.get_color_found(color), text_color='white')
            button.grid(row=row, column=col, columnspan=columnspan, padx=5, pady=5, sticky='nsew')

    #   Cor quando passa/seleciona o botão
    def get_color_found(self, base_color):
        if base_color == "#FF9900": return "#CC7A00"
        if base_color == "#00A0B0": return "#00808A"
        if base_color == "#CC3300": return "#AA2B00"
        if base_color == "#555555": return "#777777"
        return base_color
    
    '''Tratativa de número novo, negativo, duplicado'''
    def append_num(self, num):
        if self.new_num:
            self.num_atual = num 
            self.new_num = False
            self.display.set(self.num_atual)
        else:
            if self.num_atual == '0' and num != '0':
                self.num_atual = num
            elif self.num_atual == '-0' and num != '0':
                self.num_atual = '-' + num
            elif self.num_atual == '0' and num == '0':
                pass
            else:
                self.num_atual += num
            self.display.set(self.num_atual)

    '''Tratativa de número decimal'''
    def append_decimal(self):
        if self.new_num:
            self.num_atual = '0.'
            self.new_num = False
            self.display.set('0.')
        elif '.' not in self.num_atual:
            self.num_atual += '.'
            self.display.set(self.num_atual)
    
    '''Seleção de Operadores'''
    def select_op(self, op):
        try:
            num = float(self.num_atual)
            if self.n1 is None:
                self.n1 = num
            elif not self.new_num:
                result = calcular(self.n1, num, self.op)
                if result is None:
                    self.display.set('Erro: Divisão por 0')
                    self.clear_state(); return
                self.n1 = result
                self.format_display(self.n1)

            self.op = op
            formatted_n1 = str(int(self.n1)) if self.n1.is_integer() else str(self.n1)
            self.display.set(f'{formatted_n1} {self.op}')
            self.new_num = True
        except ValueError:
            self.display.set('ERRO')
            self.clear_all()
        except Exception as e:
            self.display.set(f'ERRO: {e}')
            self.clear_all()

    '''Resultado Final'''
    def calcular (self):
        if self.n1 is None or self.op is None: return
        try:
            n2 = float(self.num_atual)
            result = calcular(self.n1, n2, self.op)
            if result is None and self.op == '/':
                self.display.set('Erro: Divisão por 0')
                self.clear_state(); return
            self.format_display(result)
            self.n1 = None
            self.op = None
            self.new_num = True
        except ValueError:
            self.display.set('ERRO')
            self.clear_all()
        except Exception as e:
            self.display.set(f'ERRO: {e}')
            self.clear_all()

    '''Tecla C = Clear All '''
    def clear_all(self):
        self.num_atual = '0'
        self.display.set('0')
        self.clear_state()

    '''Apagar estados da calculadora = Clear State'''
    def clear_state(self):
        self.n1 = None
        self.op = None
        self.new_num = False

    '''Números de exibição no display'''
    def format_display(self, num):
        if isinstance(num, float) and num.is_integer():
            self.num_atual = str(int(num))
            self.display.set(str(int(num)))
        else: 
            self.num_atual = str(num)
            self.display.set(str(num))

    ''' Eventos do teclado'''
    def handle_key_press(self, event):
        key = event.char
        keysym = event.keysym

        if key.isdigit(): self.append_num(key)
        elif key == '.': self.append_decimal()
        elif key in ['+', '*', '/']: self.select_op(key)
        elif key == '-':
        # Diferenciar negativo X operador
            if self.new_num or self.num_atual == '0' or self.num_atual == '':
                if self.num_atual == '-': pass
                else:
                    self.num_atual = '-'
                    self.display.set('-')
                    self.new_num = False
            else: self.select_op(key)
        elif keysym == 'Return': self.calcular()
        elif keysym == 'BackSpace':
            if self.display.get().startswith('ERRO'): self.clear_all()
            elif self.num_atual != '0':
                if len(self.num_atual) > 1:
                    self.num_atual = self.num_atual[:-1]
                    self.display.set(self.num_atual)
                else:
                    self.num_atual = '0'
                    self.display.set('0')
            else:
                self.num_atual = '0'
                self.display.set('0')
        elif key.lower() == 'c': self.clear_all()

if __name__ == '__main__':
    root = ctk.CTk()
    app = Calcular(root)
    root.mainloop()
